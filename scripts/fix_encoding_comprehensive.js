const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–∞–ø–ø–∏–Ω–≥ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é
const encodingMap = {
  // –°—Ç–∏–ª–∏
  '√ê¬°√ê¬æ√ê¬≤√ë√ê¬µ√ê¬º√ê¬µ√ê¬Ω√ê¬Ω√ê¬∞√ë': '–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è',
  '√ê√ê¬µ√ê¬æ√ê¬∫√ê¬ª√ê¬∞√ë√ë√ê¬∏√ê¬∫√ê¬∞': '–ù–µ–æ–∫–ª–∞—Å—Å–∏–∫–∞', 
  '√ê√ê¬ª√ê¬∞√ë√ë√ê¬∏√ê¬∫√ê¬∞': '–ö–ª–∞—Å—Å–∏–∫–∞',
  '√ê¬°√ê¬∫√ë√ë√ë√ê¬∞√ë': '–°–∫—Ä—ã—Ç–∞—è',
  
  // –ö–∞—Ç–µ–≥–æ—Ä–∏–∏
  '√ê√ê¬µ√ê¬∂√ê¬∫√ê¬æ√ê¬º√ê¬Ω√ê¬∞√ë√ê¬Ω√ë√ê¬µ √ê¬¥√ê¬≤√ê¬µ√ë√ê¬∏': '–ú–µ–∂–∫–æ–º–Ω–∞—Ç–Ω—ã–µ –¥–≤–µ—Ä–∏',
  '√ê√ê¬≤√ê¬µ√ë√ê¬∏ √ê¬≤√ë √ê¬∫√ê¬≤√ê¬∞√ë√ë√ê¬∏√ë√ë': '–î–≤–µ—Ä–∏ –≤ –∫–≤–∞—Ä—Ç–∏—Ä—É',
  '√ê√ê¬≤√ê¬µ√ë√ê¬∏ √ê¬≤ √ê¬¥√ê¬æ√ê¬º': '–î–≤–µ—Ä–∏ –≤ –¥–æ–º',
  
  // –ú–∞—Ç–µ—Ä–∏–∞–ª—ã
  '√ê√ê√ê¬•': '–ü–í–•',
  '√ê√ê√ê¬¢': '–ü–≠–¢',
  '√ê√ê¬Ω√ê¬∞√ê¬º√ê¬µ√ê¬ª√ë': '–≠–º–∞–ª—å',
  '√ê√ê¬∞√ê¬Ω√ê¬æ√ë√ê¬µ√ê¬∫√ë': '–ù–∞–Ω–æ—Ç–µ–∫—Å',
  '√ê√ê¬µ√ê¬ª√ê¬µ√ê¬Ω√ê¬∏√ê¬Ω': '–ú–µ–ª–∞–º–∏–Ω',
  '√ê√ê¬∏√ë√ê¬æ√ê¬≤√ê¬∞√ê¬Ω√ê¬∏√ê¬µ': '–õ–∞–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ',
  
  // –¶–≤–µ—Ç–∞
  '√ê√ê¬µ√ê¬ª√ë√ê¬π': '–ë–µ–ª—ã–π',
  '√ê√ê¬µ√ê¬∂√ê¬µ√ê¬≤√ë√ê¬π': '–ë–µ–∂–µ–≤—ã–π',
  '√ê¬°√ê¬µ√ë√ë√ê¬π': '–°–µ—Ä—ã–π',
  '√ê¬ß√ê¬µ√ë√ê¬Ω√ë√ê¬π': '–ß–µ—Ä–Ω—ã–π',
  '√ê√ê¬æ√ë√ê¬∏√ë√ê¬Ω√ê¬µ√ê¬≤√ë√ê¬π': '–ö–æ—Ä–∏—á–Ω–µ–≤—ã–π',
  '√ê√ê¬∏√ê¬Ω√ê¬∏√ê¬π': '–°–∏–Ω–∏–π',
  '√ê√ê¬∞√ê¬ª√ê¬∞√ë√ë√ê¬∏√ê¬Ω√ê¬æ√ê¬≤√ë√ê¬π': '–ú–∞–ª–∞—Ö–∏—Ç–æ–≤—ã–π',
  '√ê√ê¬æ√ê¬ª√ê¬æ√ë√ë√ê¬æ√ê¬π': '–ó–æ–ª–æ—Ç–æ–π',
  '√ê¬°√ê¬µ√ë√ê¬µ√ê¬±√ë√ë√ê¬Ω√ë√ê¬π': '–°–µ—Ä–µ–±—Ä—è–Ω—ã–π',
  
  // –¢–∏–ø—ã –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π
  '√ê √ê¬∞√ë√ê¬ø√ê¬∞√ë√ê¬Ω√ê¬∞√ë': '–†–∞—Å–ø–∞—à–Ω–∞—è',
  '√ê¬°√ê¬∫√ê¬ª√ê¬∞√ê¬¥√ê¬Ω√ê¬∞√ë': '–°–∫–ª–∞–¥–Ω–∞—è',
  '√ê√ê¬≤√ê¬µ√ë√ê¬Ω√ê¬∞√ë': '–î–≤–µ—Ä–Ω–∞—è',
  
  // –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–∏
  '√ê√ê¬µ√ë√ë√ë√ë√ê¬∞√ê¬π√ê¬ª': '–í–µ—Å—Ç–°—Ç–∞–π–ª',
  '√ê√ê¬æ√ê¬º√ê¬µ√ê¬æ': 'Domeo',
  
  // –î—Ä—É–≥–∏–µ —Ç–µ—Ä–º–∏–Ω—ã
  '√ê√ê¬∞√ê¬∫√ê¬∞√ê¬∑√ê¬Ω√ê¬æ√ê¬µ': '–ó–∞–∫–∞–∑–Ω–æ–µ',
  '√ê√ê¬Ω√ê¬∞√ê¬ª√ê¬∏√ë√ê¬µ√ê¬Ω√ê¬∏√ê¬µ': '–ù–∞–ª–∏—á–∏–µ',
  '√ê√ê¬æ√ê¬ª√ê¬æ√ë√ê¬∫√ê¬∞': '–ö—Ä–æ–º–∫–∞',
  '√ê√ê¬æ√ê¬ª√ê¬¥√ê¬∏√ê¬Ω√ê¬≥': '–ú–æ–ª–¥–∏–Ω–≥',
  '√ê¬°√ë√ê¬µ√ê¬∫√ê¬ª√ê¬æ': '–°—Ç–µ–∫–ª–æ',
  '√ê¬§√ë√ê¬Ω√ê¬∏√ë√ë√ë√ê¬∞': '–§—É—Ä–Ω–∏—Ç—É—Ä–∞',
  '√ê√ê¬æ√ê¬º√ê¬ø√ê¬ª√ê¬µ√ê¬∫√ë': '–ö–æ–º–ø–ª–µ–∫—Ç',
  '√ê√ê¬∞√ê¬≥√ê¬Ω√ê¬∏√ë√ê¬Ω√ë√ê¬π': '–ú–∞–≥–Ω–∏—Ç–Ω—ã–π',
  '√ê√ê¬µ√ë√ê¬∞√ê¬Ω√ê¬∏√ë√ê¬µ√ë√ê¬∫√ê¬∏√ê¬π': '–ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∏–π',
  '√ê¬°√ë√ê¬∞√ê¬ª√ë': '–°—Ç–∞–ª—å',
  '√ê√ê¬∏√ê¬∫√ê¬µ√ê¬ª√ë': '–ù–∏–∫–µ–ª—å',
  '√ê√ê¬∞√ë√ë√ë√ê¬Ω√ë': '–õ–∞—Ç—É–Ω—å',
  '√ê√ê¬µ√ë√ê¬∂√ê¬∞√ê¬≤√ê¬µ√ë√ë√ê¬∞√ë √ë√ë√ê¬∞√ê¬ª√ë': '–ù–µ—Ä–∂–∞–≤–µ—é—â–∞—è —Å—Ç–∞–ª—å'
};

async function fixEncodingComprehensive() {
  console.log('üîß –ù–∞—á–∏–Ω–∞–µ–º –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏...');
  
  try {
    // –ü–æ–ª—É—á–∞–µ–º –í–°–ï —Ç–æ–≤–∞—Ä—ã
    const products = await prisma.product.findMany({
      select: {
        id: true,
        properties_data: true,
        specifications: true,
        name: true,
        description: true
      }
    });

    console.log(`üì¶ –ù–∞–π–¥–µ–Ω–æ ${products.length} —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏`);

    let fixedCount = 0;
    let totalFieldsFixed = 0;

    for (const product of products) {
      let hasChanges = false;
      const updates = {};

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥–æ–µ –ø–æ–ª–µ –Ω–∞ –∫–æ–¥–∏—Ä–æ–≤–∫—É
      const fieldsToCheck = [
        'properties_data',
        'specifications', 
        'name',
        'description'
      ];

      for (const field of fieldsToCheck) {
        if (product[field] && typeof product[field] === 'string') {
          let fixedValue = product[field];
          let fieldFixed = false;

          // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–¥–∏—Ä–æ–≤–∫–∏
          for (const [wrong, correct] of Object.entries(encodingMap)) {
            if (fixedValue.includes(wrong)) {
              fixedValue = fixedValue.replace(new RegExp(wrong, 'g'), correct);
              fieldFixed = true;
            }
          }

          // –ï—Å–ª–∏ –ø–æ–ª–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å, –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
          if (fieldFixed) {
            updates[field] = fixedValue;
            hasChanges = true;
            totalFieldsFixed++;
          }
        }
      }

      // –ï—Å–ª–∏ –µ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è, –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–≤–∞—Ä
      if (hasChanges) {
        await prisma.product.update({
          where: { id: product.id },
          data: updates
        });
        fixedCount++;
        
        if (fixedCount % 100 === 0) {
          console.log(`‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${fixedCount} —Ç–æ–≤–∞—Ä–æ–≤...`);
        }
      }
    }

    console.log(`‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ ${fixedCount} —Ç–æ–≤–∞—Ä–æ–≤, ${totalFieldsFixed} –ø–æ–ª–µ–π`);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç - –∏—â–µ–º —Ç–æ–≤–∞—Ä—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
    const testProducts = await prisma.product.findMany({
      where: {
        OR: [
          { properties_data: { contains: '–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è' } },
          { properties_data: { contains: '–ù–µ–æ–∫–ª–∞—Å—Å–∏–∫–∞' } },
          { properties_data: { contains: '–ö–ª–∞—Å—Å–∏–∫–∞' } },
          { properties_data: { contains: '–ü–í–•' } },
          { properties_data: { contains: '–ë–µ–ª—ã–π' } }
        ]
      },
      take: 10,
      select: {
        id: true,
        properties_data: true,
        name: true
      }
    });

    console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:');
    testProducts.forEach(product => {
      try {
        const props = JSON.parse(product.properties_data);
        console.log(`  - –¢–æ–≤–∞—Ä ${product.id}:`);
        console.log(`    –ù–∞–∑–≤–∞–Ω–∏–µ: "${product.name}"`);
        console.log(`    –°—Ç–∏–ª—å: "${props['Domeo_–°—Ç–∏–ª—å Web'] || '–Ω–µ –Ω–∞–π–¥–µ–Ω'}"`);
        console.log(`    –ö–∞—Ç–µ–≥–æ—Ä–∏—è: "${props['–ö–∞—Ç–µ–≥–æ—Ä–∏—è'] || '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}"`);
        console.log(`    –ú–∞—Ç–µ—Ä–∏–∞–ª: "${props['–û–±—â–µ–µ_–¢–∏–ø –ø–æ–∫—Ä—ã—Ç–∏—è'] || '–Ω–µ –Ω–∞–π–¥–µ–Ω'}"`);
        console.log(`    –¶–≤–µ—Ç: "${props['Domeo_–¶–≤–µ—Ç'] || '–Ω–µ –Ω–∞–π–¥–µ–Ω'}"`);
        console.log('    ---');
      } catch (e) {
        console.log(`  - –¢–æ–≤–∞—Ä ${product.id}: –æ—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON`);
      }
    });

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
    console.log('\nüìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π:');
    for (const [wrong, correct] of Object.entries(encodingMap)) {
      const count = await prisma.product.count({
        where: {
          OR: [
            { properties_data: { contains: correct } },
            { specifications: { contains: correct } },
            { name: { contains: correct } },
            { description: { contains: correct } }
          ]
        }
      });
      console.log(`  ${correct}: ${count} —Ç–æ–≤–∞—Ä–æ–≤`);
    }

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–¥–∏—Ä–æ–≤–∫–∏:', error);
  } finally {
    await prisma.$disconnect();
  }
}

fixEncodingComprehensive();
